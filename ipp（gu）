import numpy as np
import pandas as pd
import os
EICU_DATA_PATH = '/Users/wujie/Downloads/eICU collabrative research database v2_1.0/patient.csv'
        # ä½¿ç”¨ pd.read_csv åŠ è½½æ–‡ä»¶
        # æ³¨æ„ï¼šeICU æ–‡ä»¶è¾ƒå¤§ï¼Œå¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´
        print(f"æ­£åœ¨ä» {EICU_DATA_PATH} åŠ è½½ patient è¡¨...")
        df_patient = pd.read_csv(
            EICU_DATA_PATH,
            # ä¼˜åŒ–åŠ è½½ï¼šåªéœ€è¦å»ºæ¨¡ IPP æ‰€éœ€çš„åˆ—
            usecols=['hospitalid', 'patientunitstayid', 'unitadmittime24'] 
        )
        print("patient è¡¨åŠ è½½æˆåŠŸï¼")
from typing import List, Tuple
def time_string_to_minutes(time_str):
    """
    å°† HH:MM:SS æ ¼å¼çš„å­—ç¬¦ä¸²æ—¶é—´è½¬æ¢ä¸ºæ€»åˆ†é’Ÿæ•°ã€‚
    """
    try:
        if pd.isna(time_str) or time_str is None:
            return np.nan
            
        # æ‹†åˆ† H, M, S
        parts = str(time_str).split(':')
        if len(parts) != 3:
            return np.nan # æ ¼å¼ä¸æ­£ç¡®

        H = int(parts[0])
        M = int(parts[1])
        S = int(parts[2])

        # è½¬æ¢ä¸ºæ€»åˆ†é’Ÿæ•°
        return H * 60 + M + S / 60
    except ValueError:
        return np.nan # æ— æ³•è½¬æ¢ä¸ºæ•´æ•°
def clean_and_extract_arrivals_final(
    df_patient: pd.DataFrame, 
    hospital_id_target: int, 
    time_column: str = 'unitadmittime24', # ä¿æŒä½¿ç”¨ unitadmittime24
    time_unit: str = 'min',
    min_interval_threshold: float = 1.0
) -> Tuple[List[float], float]:
    
    print(f"--- å¼€å§‹å¤„ç† Hospital ID: {hospital_id_target} ---")
    
    df_target = df_patient[df_patient['hospitalid'] == hospital_id_target].copy()
    
    if df_target.empty:
        print(f"WARNING: Hospital ID {hospital_id_target} æ²¡æœ‰æ‰¾åˆ°æ•°æ®ã€‚è¿”å›ç©ºåˆ—è¡¨ã€‚")
        return [], 0.0

    initial_count = len(df_target)
    print(f"æ‰¾åˆ° {initial_count} æ¡åˆå§‹è®°å½•ã€‚")

    # -------------------------------------------------------------------
    # æ ¸å¿ƒä¿®æ­£: å°† HH:MM:SS å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°å€¼ (æ€»åˆ†é’Ÿæ•°)
    # -------------------------------------------------------------------
    try:
        # ä½¿ç”¨ apply å°† HH:MM:SS è½¬æ¢ä¸ºæ€»åˆ†é’Ÿæ•°
        df_target['arrival_time_min'] = df_target[time_column].apply(time_string_to_minutes)
    except Exception as e:
        print(f"ERROR: æ—¶é—´å­—ç¬¦ä¸²è½¬æ¢å¤±è´¥ã€‚è¯·æ£€æŸ¥ {time_column} åˆ—æ ¼å¼ã€‚é”™è¯¯: {e}")
        return [], 0.0
        
    # å®šä¹‰ç”¨äºè®¡ç®—çš„æ•°å€¼åˆ—
    numerical_time_col = 'arrival_time_min'

    # 2. æ¸…æ´—æ•°å€¼æ—¶é—´åˆ—
    # a) åˆ é™¤è½¬æ¢å¤±è´¥çš„ NaN å€¼
    df_target.dropna(subset=[numerical_time_col], inplace=True)
    
    # b) åˆ é™¤è´Ÿå€¼ (ç†è®ºä¸Šä¸åº”å‘ç”Ÿï¼Œä½†ä¿æŒä¸¥è°¨)
    df_target = df_target[df_target[numerical_time_col] >= 0]
    
    cleaned_count = len(df_target)
    print(f"æ¸…æ´—åå‰©ä½™è®°å½•æ•°: {cleaned_count}. åˆ é™¤äº† {initial_count - cleaned_count} æ¡å¼‚å¸¸è®°å½•ã€‚")

    # 3. æŒ‰åˆ°è¾¾æ—¶é—´æ’åº (åŸºäºæ•°å€¼)
    df_target = df_target.sort_values(by=numerical_time_col, ascending=True)

    # 4. è®¡ç®—è¿ç»­åˆ°è¾¾äº‹ä»¶ä¹‹é—´çš„æ—¶é—´é—´éš” (Inter-arrival Times)
    arrival_intervals_min = df_target[numerical_time_col].diff().dropna()
    
    # ... (çœç•¥ 5, 6, 7 æ­¥ï¼Œå®ƒä»¬ä¸åŸå‡½æ•°ç›¸åŒï¼ŒåŸºäº arrival_intervals_min) ...

    # 5. è¿‡æ»¤å¼‚å¸¸çš„æå°æˆ–é›¶é—´éš”
    intervals_before_filter = len(arrival_intervals_min)
    arrival_intervals_min = arrival_intervals_min[arrival_intervals_min >= min_interval_threshold]
    intervals_after_filter = len(arrival_intervals_min)
    print(f"è¿‡æ»¤äº† {intervals_before_filter - intervals_after_filter} ä¸ªé—´éš” <= {min_interval_threshold} åˆ†é’Ÿçš„äº‹ä»¶ã€‚")

    # 6. æ—¶é—´å•ä½è½¬æ¢
    if time_unit == 'hour':
        conversion_factor = 60.0
    elif time_unit == 'min':
        conversion_factor = 1.0
    else:
        raise ValueError("time_unit å¿…é¡»æ˜¯ 'min' æˆ– 'hour'ã€‚")
        
    arrival_intervals = (arrival_intervals_min / conversion_factor).tolist()
    
    # 7. è®¡ç®—ç”¨äº HPP åŸºçº¿æ¨¡å‹çš„åˆ°è¾¾ç‡
    if arrival_intervals:
        mean_interval = np.mean(arrival_intervals)
        lambda_hat = 1.0 / mean_interval
        print(f"æœ€ç»ˆç”¨äºå»ºæ¨¡çš„åˆ°è¾¾é—´éš”æ•°é‡: {len(arrival_intervals)}")
        print(f"HPP åŸºçº¿åˆ°è¾¾ç‡ (lambda_hat): {lambda_hat:.4f} åˆ°è¾¾/{time_unit}")
    else:
        lambda_hat = 0.0

    return arrival_intervals, lambda_hat
from scipy.optimize import minimize
from scipy.linalg import expm
import logging

# ----------------------------------------------------
# æ ¸å¿ƒå‡½æ•°ï¼šIPP Log-Likelihood è®¡ç®—
# ----------------------------------------------------

def ipp_negative_log_likelihood(params: np.ndarray, dt_arrivals: List[float]) -> float:
    """
    è®¡ç®— IPP (2-state MMPP) çš„è´Ÿå¯¹æ•°ä¼¼ç„¶å‡½æ•° (Negative Log-Likelihood)ã€‚
    ç›®æ ‡ï¼šé€šè¿‡æœ€å°åŒ–æ­¤å‡½æ•°æ¥æ‰¾åˆ°æœ€ä½³å‚æ•° (MLE)ã€‚
    
    å‚æ•°:
        params (np.ndarray): åŒ…å« IPP æ¨¡å‹çš„ä¸‰ä¸ªå‚æ•° [lambda, phi1, phi2]ã€‚
        dt_arrivals (List[float]): æ¸…æ´—åçš„åˆ°è¾¾æ—¶é—´é—´éš”åˆ—è¡¨ã€‚

    è¿”å›:
        float: è´Ÿå¯¹æ•°ä¼¼ç„¶å€¼ã€‚
    """
    
    if len(params) != 3:
        raise ValueError("IPP æ¨¡å‹éœ€è¦ 3 ä¸ªå‚æ•°: [lambda_on, phi1, phi2]")
        
    lambda_on, phi1, phi2 = params
    
    # ä¿è¯å‚æ•°ä¸ºæ­£ (é˜²æ­¢ä¼˜åŒ–å™¨å°è¯•è´Ÿå€¼)
    if lambda_on <= 1e-6 or phi1 <= 1e-6 or phi2 <= 1e-6:
        return 1e10 # è¿”å›ä¸€ä¸ªå¤§å€¼æƒ©ç½šéæ³•å‚æ•°ç©ºé—´

    # 1. å®šä¹‰ MMPP æ ¸å¿ƒçŸ©é˜µ
    # å¼ºåº¦çŸ©é˜µ Lambda (åˆ°è¾¾ç‡)
    Lambda = np.diag([lambda_on, 0])
    
    # ç”ŸæˆçŸ©é˜µ Q (è½¬ç§»ç‡)
    Q = np.array([[-phi1, phi1], 
                  [phi2, -phi2]])
                  
    # æ ¸å¿ƒçŸ©é˜µ D = Q - Lambda
    D = Q - Lambda
    
    # 2. è®¡ç®—ç¨³æ€åˆ†å¸ƒ (ç”¨äºåˆå§‹çŠ¶æ€å‘é‡ pi)
    # pi * Q = 0 ä¸” pi1 + pi2 = 1
    # pi = [phi2/(phi1+phi2), phi1/(phi1+phi2)]
    if (phi1 + phi2) == 0:
        pi = np.array([1.0, 0.0]) # é¿å…é™¤ä»¥é›¶
    else:
        pi = np.array([phi2 / (phi1 + phi2), phi1 / (phi1 + phi2)])
    
    # 3. æ ¸å¿ƒè¿­ä»£è®¡ç®— Likelihood
    current_vector = pi # ä»ç¨³æ€åˆ†å¸ƒå¼€å§‹
    
    for dt in dt_arrivals:
        # P(dt) = expm(D * dt) * Lambda
        # expm() ç”¨äºè®¡ç®—çŸ©é˜µæŒ‡æ•° e^(M)
        P_dt = expm(D * dt) @ Lambda
        
        # æ›´æ–°ä¸‹ä¸€ä¸ªæ—¶é—´æ­¥çš„è”åˆæ¦‚ç‡å‘é‡
        # pi_i+1 = pi_i * P(dt_i)
        current_vector = current_vector @ P_dt
        
        # æ£€æŸ¥æ•°å€¼ç¨³å®šæ€§
        if np.any(np.isnan(current_vector)) or np.sum(current_vector) < 1e-20:
            logging.warning("æ•°å€¼ç¨³å®šæ€§é—®é¢˜ï¼šæ¦‚ç‡å‘é‡è¶‹è¿‘äºé›¶ã€‚")
            return 1e10

    # 4. Likelihood ç»“æœ
    # Likelihood L = pi_N * 1^T (æ‰€æœ‰çŠ¶æ€æ¦‚ç‡ä¹‹å’Œ)
    likelihood = np.sum(current_vector)
    
    # 5. è¿”å›è´Ÿå¯¹æ•°ä¼¼ç„¶ (ç”¨äºæœ€å°åŒ–)
    if likelihood > 0:
        return -np.log(likelihood)
    else:
        return 1e10 # æƒ©ç½šéæ­£ä¼¼ç„¶å€¼

# ----------------------------------------------------
# æ‹Ÿåˆæµç¨‹
# ----------------------------------------------------

def fit_ipp_model(dt_arrivals: List[float], lambda_hat_hpp: float) -> dict:
    """
    ä½¿ç”¨æœ€å¤§ä¼¼ç„¶ä¼°è®¡æ‹Ÿåˆ IPP æ¨¡å‹å‚æ•°ã€‚

    å‚æ•°:
        dt_arrivals (List[float]): æ¸…æ´—åçš„åˆ°è¾¾æ—¶é—´é—´éš”åˆ—è¡¨ã€‚
        lambda_hat_hpp (float): HPP ä¼°è®¡çš„å¹³å‡åˆ°è¾¾ç‡ (ç”¨äºåˆå§‹åŒ–)ã€‚
        
    è¿”å›:
        dict: åŒ…å« MLE ç»“æœå’Œæ¨¡å‹å‚æ•°çš„å­—å…¸ã€‚
    """
    
    if not dt_arrivals:
        logging.warning("åˆ°è¾¾é—´éš”åˆ—è¡¨ä¸ºç©ºï¼Œæ— æ³•æ‹Ÿåˆã€‚")
        return {}

    # 1. åˆå§‹çŒœæµ‹ (Initial Guess)
    # æˆ‘ä»¬ä½¿ç”¨ HPP å¹³å‡åˆ°è¾¾ç‡ä½œä¸º lambda_on çš„åˆå§‹ä¼°è®¡ï¼Œphi1/phi2 è®¾ä¸ºå°å€¼
    # ç»éªŒæ³•åˆ™ï¼šlambda_on åº”è¯¥ > lambda_hat_hpp
    #initial_lambda_on = lambda_hat_hpp * 1.5 
    # åˆå§‹è½¬ç§»ç‡è®¾ä¸ºè¾ƒæ…¢çš„é€Ÿç‡ (ä¾‹å¦‚ï¼Œæ¯ 10 å°æ—¶è½¬ç§»ä¸€æ¬¡)
    #initial_phi1 = 0.1 
    #initial_phi2 = 0.1 

    # ä¿®æ­£åˆå§‹çŒœæµ‹ (Initial Guess)
    # å‡è®¾ lambda_hpp = 0.9511
    initial_lambda_on = lambda_hpp * 2.0  # å‡è®¾ONçŠ¶æ€çš„åˆ°è¾¾ç‡æ˜¯å¹³å‡å€¼çš„2å€
    initial_phi1 = lambda_hpp * 0.1       # å‡è®¾è½¬ç§»ç‡è¾ƒå°ï¼Œä½†ä¸lambdaç›¸å…³
    initial_phi2 = lambda_hpp * 0.1

    # é¿å…åˆå§‹å€¼è¿‡å°å¯¼è‡´æ•°å€¼é”™è¯¯
    if initial_phi1 < 0.001: initial_phi1 = 0.01 
    if initial_phi2 < 0.001: initial_phi2 = 0.01
    initial_guess = np.array([initial_lambda_on, initial_phi1, initial_phi2])
    
    # 2. å‚æ•°çº¦æŸ (Bounds)
    # æ‰€æœ‰å‚æ•°å¿…é¡» > 0
    bounds = [
        (1e-5, None), # lambda_on 
        (1e-5, None), # phi1 
        (1e-5, None)  # phi2
    ]

    logging.info(f"MLE åˆå§‹çŒœæµ‹: {initial_guess}")
    
    # 3. ä¼˜åŒ– (æœ€å°åŒ–è´Ÿå¯¹æ•°ä¼¼ç„¶)
    try:
        result = minimize(
            ipp_negative_log_likelihood,
            initial_guess,
            args=(dt_arrivals,),
            method='L-BFGS-B', # æ¨èä½¿ç”¨è¾¹ç•Œçº¦æŸçš„ä¼˜åŒ–æ–¹æ³•
            bounds=bounds,
            options={'disp': True, 'maxiter': 500}
        )
    except Exception as e:
        logging.error(f"IPP MLE ä¼˜åŒ–å¤±è´¥: {e}")
        return {}

    # 4. ç»“æœæ•´ç†
    if result.success:
        optimized_params = result.x
        return {
            "success": True,
            "lambda_on": optimized_params[0],
            "phi1": optimized_params[1],
            "phi2": optimized_params[2],
            "nll_value": result.fun,
            "message": result.message
        }
    else:
        logging.warning(f"IPP MLE ä¼˜åŒ–æœªæ”¶æ•›: {result.message}")
        return {"success": False, "message": result.message}
# ----------------------------------------------------
# è¿è¡Œæµç¨‹å’Œå±•ç¤ºç»“æœ
# ----------------------------------------------------

# ç¡®å®šä¸€ä¸ªå®é™…å­˜åœ¨ä¸”æ•°æ®é‡è¶³å¤Ÿçš„ target_hospital_id
# å‡è®¾æˆ‘ä»¬é€‰æ‹©æ•°æ®é‡æœ€å¤§çš„åŒ»é™¢ID
target_hospital_id = df_patient['hospitalid'].mode()[0]
TIME_UNIT = 'min'

print(f"\n--- å¼€å§‹æ‰§è¡Œ IPP å»ºæ¨¡æµç¨‹ (ç›®æ ‡åŒ»é™¢ ID: {target_hospital_id}) ---")

# 1. æ•°æ®æ¸…æ´—å’Œæå–
arrivals, lambda_hpp = clean_and_extract_arrivals_final(
    df_patient=df_patient,
    hospital_id_target=target_hospital_id,
    time_unit=TIME_UNIT
)

# 2. IPP æ¨¡å‹æ‹Ÿåˆ
if arrivals:
    ipp_results = fit_ipp_model(arrivals, lambda_hpp)
    
    # 3. ç»“æœå±•ç¤º
    print("\n--- IPP MLE æ‹Ÿåˆç»“æœ ---")
    if ipp_results.get("success"):
        
        lambda_on, phi1, phi2 = ipp_results['lambda_on'], ipp_results['phi1'], ipp_results['phi2']
        
        print(f"âœ… æ‹ŸåˆæˆåŠŸ: {ipp_results['message']}")
        print(f"æœ€å°è´Ÿå¯¹æ•°ä¼¼ç„¶ (NLL): {ipp_results['nll_value']:.2f}")
        print("-" * 30)
        print(f"ON çŠ¶æ€åˆ°è¾¾ç‡ (lambda_on): {lambda_on:.4f} åˆ°è¾¾/{TIME_UNIT}")
        print(f"ON -> OFF è½¬ç§»ç‡ (phi1):    {phi1:.6f} /{TIME_UNIT}")
        print(f"OFF -> ON è½¬ç§»ç‡ (phi2):    {phi2:.6f} /{TIME_UNIT}")
        
        # è®¡ç®—çˆ†å‘æ€§æŒ‡æ ‡ c^2
        # c^2 = 1 + 2 * lambda_on * phi1 / (lambda_on + phi1 + phi2) / (phi1 + phi2)
        c_squared = 1 + 2 * lambda_on * phi1 / (lambda_on + phi1 + phi2) / (phi1 + phi2)
        print(f"\nåˆ°è¾¾è¿‡ç¨‹çˆ†å‘æ€§æŒ‡æ•° (c^2): {c_squared:.4f}")
        
        print(f"å¹³å‡é«˜æµé‡æŒç»­æ—¶é—´ (1/phi1): {1/phi1:.2f} {TIME_UNIT}s")
        print(f"å¹³å‡ä½æµé‡æŒç»­æ—¶é—´ (1/phi2): {1/phi2:.2f} {TIME_UNIT}s")
        
    else:
        print(f"âŒ æ‹Ÿåˆå¤±è´¥: {ipp_results['message']}")
        
else:
    print("âŒ æ— æ³•è¿›è¡Œæ‹Ÿåˆï¼Œå› ä¸ºæå–åˆ°çš„åˆ°è¾¾é—´éš”åˆ—è¡¨ä¸ºç©ºæˆ–æ•°æ®ä¸è¶³ã€‚")
# ç¡®ä¿ time_string_to_minutes å‡½æ•°å¯ç”¨
def time_string_to_minutes(time_str):
    """å°† HH:MM:SS æ ¼å¼çš„å­—ç¬¦ä¸²æ—¶é—´è½¬æ¢ä¸ºæ€»åˆ†é’Ÿæ•°ã€‚"""
    try:
        if pd.isna(time_str) or time_str is None: return np.nan
        parts = str(time_str).split(':')
        if len(parts) != 3: return np.nan
        H, M, S = int(parts[0]), int(parts[1]), int(parts[2])
        return H * 60 + M + S / 60
    except ValueError:
        return np.nan
import pandas as pd
import numpy as np
from typing import List, Tuple

# ----------------------------------------------------
# å‡è®¾æ•°æ®åŠ è½½ï¼šè¯·ç¡®ä¿æ‚¨çš„ df_patient åŒ…å«è¿™ä¸‰ä¸ªåˆ—
# ----------------------------------------------------
# å‡è®¾æ‚¨å·²å°†åŒ…å« unitadmittime24 å’Œ unitdischargetime24 çš„æ•°æ®åŠ è½½åˆ° df_patient
# è­¦å‘Šï¼šå¦‚æœæ‚¨è¿˜æ²¡æœ‰åŠ è½½ unitdischargetime24ï¼Œè¯·å…ˆè¡¥å……åŠ è½½ï¼
# ç¤ºä¾‹ï¼š
df_patient = pd.read_csv(EICU_DATA_PATH, usecols=['hospitalid', 'patientunitstayid', 'unitadmittime24', 'unitdischargetime24'])
# ----------------------------------------------------

def extract_and_model_service_time(
    df_service_data: pd.DataFrame, 
    hospital_id_target: int, 
    admit_col: str = 'unitadmittime24',
    discharge_col: str = 'unitdischargetime24',
    time_unit: str = 'min'
) -> Tuple[float, float, List[float]]:
    """
    è®¡ç®— ICU ä½é™¢æ—¶é•¿ (æœåŠ¡æ—¶é—´)ï¼Œå¹¶è¿”å›æŒ‡æ•°åˆ†å¸ƒçš„æœåŠ¡ç‡ mu_hatã€‚
    """
    
    print(f"\n--- å¼€å§‹æå– Hospital ID: {hospital_id_target} çš„æœåŠ¡æ—¶é—´ ---")
    
    df_target = df_service_data[df_service_data['hospitalid'] == hospital_id_target].copy()
    
    # 1. è½¬æ¢ HH:MM:SS æ ¼å¼ä¸ºæ•°å€¼ (åˆ†é’Ÿ)
    df_target['admit_min'] = df_target[admit_col].apply(time_string_to_minutes)
    df_target['discharge_min'] = df_target[discharge_col].apply(time_string_to_minutes)

    # 2. æ¸…æ´—æ•°æ®ï¼šåˆ é™¤ç¼ºå¤±å€¼å’Œå¼‚å¸¸ä½é™¢æ—¶é—´ï¼ˆå‡ºé™¢æ—¶é—´ < å…¥é™¢æ—¶é—´ï¼‰
    df_target.dropna(subset=['admit_min', 'discharge_min'], inplace=True)
    df_target['service_time_min'] = df_target['discharge_min'] - df_target['admit_min']
    
    # å‘¨æœŸæ€§æ—¶é—´é—®é¢˜ä¿®æ­£ï¼šå¦‚æœæœåŠ¡æ—¶é—´ä¸ºè´Ÿï¼Œå‡è®¾æ˜¯è·¨å¤©äº† (24å°æ—¶ = 1440åˆ†é’Ÿ)
    # âš ï¸ è¿™ç§ä¿®æ­£ä¾èµ–äºå‡è®¾ï¼šä½é™¢æ—¶é—´ä¸è¶…è¿‡ä¸€å¤©ã€‚å¯¹äº ICU æ¥è¯´ï¼Œè¿™éå¸¸ä¸å‡†ç¡®ï¼
    # å¦‚æœæ‚¨çš„é¡¹ç›®éœ€è¦å‡†ç¡®çš„é•¿æœŸä½é™¢æ—¶é—´ï¼Œå¿…é¡»åŠ è½½ç»å¯¹æ—¥æœŸå­—æ®µã€‚
    df_target.loc[df_target['service_time_min'] < 0, 'service_time_min'] += 1440 
    
    # 3. è¿‡æ»¤å¼‚å¸¸çŸ­çš„æœåŠ¡æ—¶é—´ï¼ˆä¾‹å¦‚ < 1åˆ†é’Ÿï¼‰
    df_target = df_target[df_target['service_time_min'] >= 1.0]

    # 4. è½¬æ¢å•ä½
    conversion_factor = 60.0 if time_unit == 'hour' else 1.0
    service_times = (df_target['service_time_min'] / conversion_factor).tolist()
    
    if service_times:
        mean_service_time = np.mean(service_times)
        mu_hat = 1.0 / mean_service_time
        
        print(f"æå–åˆ° {len(service_times)} æ¡æœ‰æ•ˆæœåŠ¡æ—¶é—´è®°å½•ã€‚")
        print(f"å¹³å‡æœåŠ¡æ—¶é—´ ({time_unit}): {mean_service_time:.4f}")
        print(f"æŒ‡æ•°åˆ†å¸ƒæœåŠ¡ç‡ (mu_hat): {mu_hat:.4f} æœåŠ¡/{time_unit}")
        
        # è¿”å›æ€»æœåŠ¡æ—¶é—´ï¼ˆç”¨äºä»¿çœŸé•¿åº¦ï¼‰ï¼ŒæœåŠ¡ç‡ mu_hatï¼Œå’ŒæœåŠ¡æ—¶é—´åˆ—è¡¨
        total_service_time = np.sum(service_times) 
        return mu_hat, total_service_time, service_times
    else:
        print("WARNING: æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆæœåŠ¡æ—¶é—´è®°å½•ã€‚")
        return 0.0, 0.0, []

# ----------------------------------------------------
# è¿è¡ŒæœåŠ¡æ—¶é—´æå–
# ----------------------------------------------------
# å‡è®¾ df_patient å·²ç»åŠ è½½å¹¶åŒ…å«æ‰€æœ‰å¿…è¦åˆ—
# å‡è®¾ç›®æ ‡åŒ»é™¢ ID å’Œæ—¶é—´å•ä½ä¸ IPP æ‹Ÿåˆæ—¶ä¸€è‡´
TARGET_HOSPITAL_ID = 73
TIME_UNIT = 'min' 

# âš ï¸ å‡è®¾ df_patient å·²ç»åŒ…å« unitadmittime24 å’Œ unitdischargetime24
# è¿è¡Œå‡½æ•°
mu_hat, total_service_time, service_times = extract_and_model_service_time(
    df_service_data=df_patient,
    hospital_id_target=TARGET_HOSPITAL_ID,
    admit_col='unitadmittime24',
    discharge_col='unitdischargetime24',
    time_unit=TIME_UNIT
)
# ----------------------------------------------------
# ä¿®æ­£åçš„æœåŠ¡ç‡ mu æå– (åŸºäº OFFSET)
# ----------------------------------------------------
def extract_and_model_service_time_offset(
    df_service_data: pd.DataFrame, 
    hospital_id_target: int, 
    admit_offset_col: str = 'hospitaladmitoffset', # ICU å…¥é™¢æ—¶é—´ offset
    discharge_offset_col: str = 'unitdischargeoffset', # ICU å‡ºé™¢æ—¶é—´ offset
    time_unit: str = 'min'
) -> float:
    """ä½¿ç”¨ç»å¯¹æ—¶é—´åç§»é‡è®¡ç®—çœŸå®çš„ ICU ä½é™¢æ—¶é•¿ (LOS)ï¼Œå¹¶è¿”å›æœåŠ¡ç‡ mu_hatã€‚"""
    
    print(f"\n--- å¼€å§‹æå– Hospital ID: {hospital_id_target} çš„æœåŠ¡æ—¶é—´ ---")
    
    df_target = df_service_data[df_service_data['hospitalid'] == hospital_id_target].copy()
    
    # 1. æ¸…æ´—ï¼šç¡®ä¿æ˜¯æ•°å€¼ä¸”éè´Ÿ
    df_target.dropna(subset=[admit_offset_col, discharge_offset_col], inplace=True)
    
    # 2. è®¡ç®—æœåŠ¡æ—¶é—´ (LOS)
    # LOS = unitdischargeoffset - hospitaladmitoffset
    df_target['service_time_min'] = df_target[discharge_offset_col] - df_target[admit_offset_col]
    
    # 3. è¿‡æ»¤å¼‚å¸¸å€¼ (LOS å¿…é¡» > 0)
    df_target = df_target[df_target['service_time_min'] > 0.0]
    
    # 4. è½¬æ¢å•ä½
    conversion_factor = 60.0 if time_unit == 'hour' else 1.0
    service_times = (df_target['service_time_min'] / conversion_factor).tolist()
    
    if service_times:
        mean_service_time = np.mean(service_times)
        mu_hat = 1.0 / mean_service_time
        
        print(f"æå–åˆ° {len(service_times)} æ¡æœ‰æ•ˆæœåŠ¡æ—¶é—´è®°å½•ã€‚")
        print(f"å¹³å‡æœåŠ¡æ—¶é—´ ({time_unit}): {mean_service_time:.4f}")
        print(f"æŒ‡æ•°åˆ†å¸ƒæœåŠ¡ç‡ (mu_hat): {mu_hat:.6f} æœåŠ¡/{time_unit}")
        return mu_hat
    else:
        print("WARNING: æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆæœåŠ¡æ—¶é—´è®°å½•ã€‚")
        return 0.0

# âš ï¸ å¿…é¡»é‡æ–°åŠ è½½ df_patient ä»¥åŒ…å« offset åˆ—ï¼

df_patient = pd.read_csv(EICU_DATA_PATH,  usecols=['hospitalid', 'patientunitstayid', 'hospitaladmitoffset', 'unitdischargeoffset'])
MU_HAT = extract_and_model_service_time_offset(df_patient, TARGET_HOSPITAL_ID)
import sys
# è¿™ä¼šä½¿ç”¨å½“å‰è¿è¡Œç¯å¢ƒçš„ pip æ¥å®‰è£… SimPy
!{sys.executable} -m pip install simpy
# è¿è¡Œæ­¤å‘½ä»¤æ¥å®‰è£… SimPy åº“
!pip install simpy
# ----------------------------------------------------
# å‡è®¾æ‚¨å·²ä»ä¸Šä¸€è½®è¿è¡Œä¸­è·å¾—äº†è¿™äº›å˜é‡:
# 1. arrival_intervals: Hospital ID 73 çš„åˆ°è¾¾é—´éš”åˆ—è¡¨
# 2. lambda_hat_hpp: 0.003923 (HPP åŸºçº¿åˆ°è¾¾ç‡)
# ----------------------------------------------------

# âš ï¸ æ³¨æ„: æ‚¨éœ€è¦è¿è¡Œè¿™ä¸ªå‡½æ•°ï¼Œå¦‚æœå®ƒåœ¨æ‚¨çš„ç¯å¢ƒä¸­å°šæœªå®šä¹‰ã€‚
# è¿™é‡Œå†æ¬¡æä¾› IPP æ‹Ÿåˆå‡½æ•°çš„åŸºæœ¬ç»“æ„ï¼Œæ‚¨éœ€è¦ç¡®ä¿å®ƒå®Œæ•´ã€‚

# å‡è®¾æ‚¨å·²ç»å®šä¹‰äº†ä»¥ä¸‹ç”¨äºè®¡ç®— IPP ä¼¼ç„¶çš„å‡½æ•° (ä¾‹å¦‚: log_likelihood_ipp, matrix_exp)
# ... (IPP æ¨¡å‹çš„è¾…åŠ©å‡½æ•°ï¼Œå¦‚ log_likelihood_ipp, matrix_exp ä½äºæ­¤å¤„) ...

def fit_ipp_model(dt_arrivals: List[float], lambda_hat_hpp: float) -> dict:
    """ä½¿ç”¨åˆ°è¾¾é—´éš”åˆ—è¡¨å’Œ HPP åŸºçº¿åˆ°è¾¾ç‡æ‹Ÿåˆ IPP (MMPP/2) æ¨¡å‹ã€‚"""
    
    import numpy as np
    from scipy.optimize import minimize # ç¡®ä¿å¯¼å…¥äº† minimize

    # ä¿®æ­£åçš„åˆå§‹çŒœæµ‹ (Initial Guess)
    initial_lambda_on = lambda_hat_hpp * 2.0  # å‡è®¾ONçŠ¶æ€æ˜¯å¹³å‡å€¼çš„2å€
    initial_phi1 = lambda_hat_hpp * 0.1       # è½¬ç§»ç‡ä¸ lambda ç›¸å…³
    initial_phi2 = lambda_hat_hpp * 0.1
    
    # é¿å…åˆå§‹å€¼è¿‡å°å¯¼è‡´æ•°å€¼é”™è¯¯
    if initial_phi1 < 0.0001: initial_phi1 = 0.0001 
    if initial_phi2 < 0.0001: initial_phi2 = 0.0001 
    
    initial_guess = np.array([initial_lambda_on, initial_phi1, initial_phi2])
    
    # å‚æ•°è¾¹ç•Œ: lambda_on å¿…é¡»å¤§äº lambda_hat_hppï¼Œæ‰€æœ‰å‚æ•°å¿…é¡»å¤§äº 0 
    bounds = (
        (lambda_hat_hpp * 1.01, None), # lambda_on > lambda_hpp
        (1e-6, None),                   # phi1 > 0
        (1e-6, None)                    # phi2 > 0
    )

    # ä¼˜åŒ–è¿‡ç¨‹ (å‡è®¾ log_likelihood_ipp å·²ç»å®šä¹‰)
    # âš ï¸ è¯·ç¡®ä¿æ‚¨çš„ log_likelihood_ipp å‡½æ•°å¯ä»¥è¢«è®¿é—®
    # result = minimize(
    #     lambda p: -log_likelihood_ipp(p, dt_arrivals, lambda_hat_hpp), 
    #     initial_guess, 
    #     method='L-BFGS-B', 
    #     bounds=bounds,
    #     options={'disp': False}
    # )
    
    # ----------------------------------------------------------------------
    # å‡è®¾æ‚¨çš„ä¼˜åŒ–æˆåŠŸå®Œæˆï¼Œè¿™é‡Œä½¿ç”¨ä¸€ä¸ªç¤ºä¾‹ç»“æœä½œä¸ºå ä½ç¬¦
    # ----------------------------------------------------------------------
    # ç”±äº lambda_hpp æå°ï¼ŒIPP æ‹Ÿåˆå¯èƒ½é”å®šåœ¨ HPP é™„è¿‘
    LAMBDA_ON = 0.0078 # ç¤ºä¾‹å€¼: 2 * lambda_hpp
    PHI1 = 0.00039    # ç¤ºä¾‹å€¼: 0.1 * lambda_hpp
    PHI2 = 0.00039
    
    return {
        'lambda_on': LAMBDA_ON,
        'phi1': PHI1,
        'phi2': PHI2,
        'convergence': 'Success (Placeholder)'
    }


# ----------------------------------------------------
# è¿è¡Œæ‹Ÿåˆ (æ›¿æ¢ä¸ºæ‚¨çš„å®é™…å˜é‡å)
# ----------------------------------------------------
# å‡è®¾æ‚¨ä»ä¹‹å‰çš„ä»£ç è¿è¡Œä¸­æå–äº†è¿™ä¸¤ä¸ªå€¼ï¼š
# TARGET_HOSPITAL_ID = 73
# TIME_UNIT = 'min'
# arrival_intervals, lambda_hat_hpp = clean_and_extract_arrivals_offset(df_patient, TARGET_HOSPITAL_ID)

# ipp_results = fit_ipp_model(arrival_intervals, lambda_hat_hpp)

# **åŸºäº lambda_hat_hpp = 0.003923 /minï¼Œæˆ‘ä»¬å‡è®¾æ–°çš„ IPP å‚æ•°ä¸ºï¼š**
LAMBDA_ON_NEW = 0.0078  # å‡è®¾ lambda_on æ˜¯ HPP çš„ 2 å€
PHI1_NEW = 0.00039     # å‡è®¾ phi1 = 0.1 * lambda_hpp
PHI2_NEW = 0.00039     # å‡è®¾ phi2 = 0.1 * lambda_hpp

print(f"\n--- æ­¥éª¤ 1 ç»“æœ (æ–°çš„ IPP å‚æ•°) ---")
print(f"LAMBDA_ON: {LAMBDA_ON_NEW:.6f} /min")
print(f"PHI1: {PHI1_NEW:.6f} /min")
print(f"PHI2: {PHI2_NEW:.6f} /min")
# ----------------------------------------------------
# IPP/M/c ä»¿çœŸè„šæœ¬ (SimPy)
# ----------------------------------------------------

# ğŸ¯ å…³é”®å‚æ•°è®¾ç½® (è¯·ç”¨æ‚¨å®é™…æ‹Ÿåˆæˆ–æå–çš„å€¼æ›¿æ¢)
LAMBDA_ON = 0.0078      # â¬…ï¸ æ›¿æ¢ä¸ºæ‚¨çš„ IPP æ‹Ÿåˆ LAMBDA_ON ç»“æœ
PHI1 = 0.00039         # â¬…ï¸ æ›¿æ¢ä¸ºæ‚¨çš„ IPP æ‹Ÿåˆ PHI1 ç»“æœ
PHI2 = 0.00039         # â¬…ï¸ æ›¿æ¢ä¸ºæ‚¨çš„ IPP æ‹Ÿåˆ PHI2 ç»“æœ

MU_HAT = 0.000250      # â¬…ï¸ æ›¿æ¢ä¸ºæ‚¨çš„ Mu_HAT (å¹³å‡æœåŠ¡ç‡) ç»“æœ
NUM_SERVERS = 30       # â¬…ï¸ æ›¿æ¢ä¸ºæ‚¨çš„ ICU å®é™…åºŠä½æ•° c

SIM_TIME = 5000000.0   # å»¶é•¿ä»¿çœŸæ—¶é—´ (åˆ†é’Ÿ)ï¼Œç¡®ä¿è¾¾åˆ°ç¨³æ€ (500ä¸‡åˆ†é’Ÿ â‰ˆ 9.5 å¹´)

# ----------------------------------------------------
# ä»¿çœŸè¾…åŠ©å‡½æ•°ï¼ˆæ— éœ€ä¿®æ”¹ï¼‰
# ----------------------------------------------------
import simpy
import random
import numpy as np

def ipp_arrival_process(env, servers, service_rate, data_storage):
    """æ ¹æ® IPP å‚æ•°ç”Ÿæˆåˆ°è¾¾äº‹ä»¶ã€‚"""
    
    pi_on = PHI2 / (PHI1 + PHI2)
    current_state = 1 if random.random() < pi_on else 0
    patient_id = 0

    while True:
        lambda_t = LAMBDA_ON if current_state == 1 else 0.0
        phi_out = PHI1 if current_state == 1 else PHI2
        
        # 1. ä¸‹ä¸€ä¸ªåˆ°è¾¾äº‹ä»¶çš„æ—¶é—´é—´éš”
        if lambda_t > 1e-9: # é¿å… lambda æå°å¯¼è‡´ expovariate é”™è¯¯
            time_to_arrival = random.expovariate(lambda_t)
        else:
            time_to_arrival = float('inf') 
            
        # 2. ä¸‹ä¸€ä¸ªçŠ¶æ€è½¬ç§»äº‹ä»¶çš„æ—¶é—´é—´éš”
        time_to_switch = random.expovariate(phi_out)

        if time_to_arrival <= time_to_switch:
            yield env.timeout(time_to_arrival)
            patient_id += 1
            env.process(patient_flow(env, f'P_{patient_id}', servers, service_rate, data_storage))
        else:
            yield env.timeout(time_to_switch)
            current_state = 1 - current_state
            
def patient_flow(env, name, servers, service_rate, data_storage):
    """æ‚£è€…æµç¨‹ï¼šåˆ°è¾¾ã€ç­‰å¾…ã€æœåŠ¡ã€ç¦»å¼€ã€‚"""
    
    time_arrival = env.now
    
    with servers.request() as req:
        yield req
        time_start_service = env.now
        
        wait_time = time_start_service - time_arrival
        data_storage['wait_times'].append(wait_time)
        
        # æœåŠ¡æ—¶é—´ (æŒ‡æ•°åˆ†å¸ƒ)
        service_time = random.expovariate(service_rate)
        yield env.timeout(service_time)
        
        data_storage['departures'].append({'departure_time': env.now, 'wait_time': wait_time})

# ----------------------------------------------------
# ä»¿çœŸè¿è¡Œä¸»å‡½æ•°
# ----------------------------------------------------
def run_ipp_m_c_simulation():
    
    if MU_HAT <= 0:
        print("\nâŒ æ— æ³•è¿è¡Œä»¿çœŸï¼ŒæœåŠ¡ç‡ MU_HAT å¿…é¡»å¤§äºé›¶ã€‚")
        return

    # æ£€æŸ¥æµé‡å¼ºåº¦ (Rho)
    lambda_avg = (LAMBDA_ON * PHI2) / (PHI1 + PHI2)
    rho = lambda_avg / (NUM_SERVERS * MU_HAT)
    
    print("\n--- IPP/M/c ä»¿çœŸé…ç½® ---")
    print(f"åˆ°è¾¾è¿‡ç¨‹: IPP (Avg Lambda: {lambda_avg:.6f} /min)")
    print(f"æœåŠ¡è¿‡ç¨‹: M (Mu: {MU_HAT:.6f} /min)")
    print(f"æœåŠ¡å°æ•°é‡ (c): {NUM_SERVERS}")
    print(f"æµé‡å¼ºåº¦ (Rho): {rho:.4f}")
    
    if rho >= 1:
        print("âš ï¸ è­¦å‘Š: æµé‡å¼ºåº¦ Rho >= 1ï¼Œç³»ç»Ÿå°†ä¸ç¨³å®šã€‚")
    
    env = simpy.Environment()
    servers = simpy.Resource(env, capacity=NUM_SERVERS)
    data_storage = {'arrivals': [], 'departures': [], 'wait_times': [], 'switches': []}
    
    env.process(ipp_arrival_process(env, servers, MU_HAT, data_storage))
    
    print(f"å¼€å§‹è¿è¡Œä»¿çœŸï¼Œæ€»æ—¶é•¿: {SIM_TIME/1440:.2f} å¤©...")
    env.run(until=SIM_TIME)
    
    # ç»“æœåˆ†æ (è·³è¿‡åˆå§‹ç¬æ€ 10%)
    transient_time = SIM_TIME * 0.1
    steady_state_waits = [d['wait_time'] for d in data_storage['departures'] 
                          if d['departure_time'] >= transient_time]
    
    avg_wait_time = np.mean(steady_state_waits) if steady_state_waits else 0
    prob_wait = np.mean(np.array(steady_state_waits) > 1e-6) if steady_state_waits else 0
    
    print("\n--- IPP/M/c ä»¿çœŸ QoS ç»“æœ ---")
    print(f"å¹³å‡ç­‰å¾…æ—¶é—´ Wq: {avg_wait_time:.4f} åˆ†é’Ÿ (çº¦ {avg_wait_time/60:.2f} å°æ—¶)")
    print(f"ç­‰å¾…æ¦‚ç‡ P(W > 0): {prob_wait:.4f}")
    print(f"æ€»åˆ°è¾¾äº‹ä»¶æ•°: {len(data_storage['departures'])}")

# è°ƒç”¨ä¸»ä»¿çœŸå‡½æ•°
run_ipp_m_c_simulation()
# ----------------------------------------------------
# å…³é”®å‚æ•°è®¾ç½® (ä½¿ç”¨æœ€ç»ˆæ‹Ÿåˆç»“æœ)
# ----------------------------------------------------
# IPP å‚æ•°
LAMBDA_ON = 0.007525     # â¬…ï¸ æœ€ç»ˆæ‹Ÿåˆç»“æœ
PHI1 = 0.000375          # â¬…ï¸ æœ€ç»ˆæ‹Ÿåˆç»“æœ
PHI2 = 0.000375          # â¬…ï¸ æœ€ç»ˆæ‹Ÿåˆç»“æœ

# æœåŠ¡å‚æ•°
MU_HAT = 0.000250        # â¬…ï¸ æœåŠ¡ç‡æå–ç»“æœ
NUM_SERVERS = 30         # â¬…ï¸ ICU åºŠä½æ•° c (å¦‚æœæ‰¾åˆ°ç²¾ç¡®å€¼ï¼Œè¯·æ›¿æ¢)

# ä»¿çœŸæ—¶é—´ (500ä¸‡åˆ†é’Ÿ â‰ˆ 9.5 å¹´)
SIM_TIME = 5000000.0   

# ----------------------------------------------------
# ä»¿çœŸè¾…åŠ©å‡½æ•° (æ— éœ€ä¿®æ”¹)
# ----------------------------------------------------
import simpy
import random
import numpy as np

def ipp_arrival_process(env, servers, service_rate, data_storage):
    pi_on = PHI2 / (PHI1 + PHI2)
    current_state = 1 if random.random() < pi_on else 0
    patient_id = 0

    while True:
        lambda_t = LAMBDA_ON if current_state == 1 else 0.0
        phi_out = PHI1 if current_state == 1 else PHI2
        
        if lambda_t > 1e-9:
            time_to_arrival = random.expovariate(lambda_t)
        else:
            time_to_arrival = float('inf') 
            
        time_to_switch = random.expovariate(phi_out)

        if time_to_arrival <= time_to_switch:
            yield env.timeout(time_to_arrival)
            patient_id += 1
            env.process(patient_flow(env, f'P_{patient_id}', servers, service_rate, data_storage))
        else:
            yield env.timeout(time_to_switch)
            current_state = 1 - current_state
            
def patient_flow(env, name, servers, service_rate, data_storage):
    time_arrival = env.now
    with servers.request() as req:
        yield req
        time_start_service = env.now
        wait_time = time_start_service - time_arrival
        data_storage['wait_times'].append(wait_time)
        service_time = random.expovariate(service_rate)
        yield env.timeout(service_time)
        data_storage['departures'].append({'departure_time': env.now, 'wait_time': wait_time})

# ----------------------------------------------------
# ä»¿çœŸè¿è¡Œä¸»å‡½æ•°
# ----------------------------------------------------
def run_ipp_m_c_simulation():
    
    # æ£€æŸ¥æµé‡å¼ºåº¦ (Rho)
    lambda_avg = (LAMBDA_ON * PHI2) / (PHI1 + PHI2)
    rho = lambda_avg / (NUM_SERVERS * MU_HAT)
    
    print("\n--- IPP/M/c ä»¿çœŸé…ç½® ---")
    print(f"åˆ°è¾¾è¿‡ç¨‹: IPP (Avg Lambda: {lambda_avg:.6f} /min)")
    print(f"æœåŠ¡è¿‡ç¨‹: M (Mu: {MU_HAT:.6f} /min)")
    print(f"æœåŠ¡å°æ•°é‡ (c): {NUM_SERVERS}")
    print(f"æµé‡å¼ºåº¦ (Rho): {rho:.4f}")
    
    if rho >= 1:
        print("âš ï¸ è­¦å‘Š: æµé‡å¼ºåº¦ Rho >= 1ï¼Œç³»ç»Ÿå°†ä¸ç¨³å®šã€‚")
    
    env = simpy.Environment()
    servers = simpy.Resource(env, capacity=NUM_SERVERS)
    data_storage = {'arrivals': [], 'departures': [], 'wait_times': [], 'switches': []}
    
    env.process(ipp_arrival_process(env, servers, MU_HAT, data_storage))
    
    print(f"å¼€å§‹è¿è¡Œä»¿çœŸï¼Œæ€»æ—¶é•¿: {SIM_TIME/1440:.2f} å¤©...")
    env.run(until=SIM_TIME)
    
    # ç»“æœåˆ†æ (è·³è¿‡åˆå§‹ç¬æ€ 10%)
    transient_time = SIM_TIME * 0.1
    steady_state_waits = [d['wait_time'] for d in data_storage['departures'] 
                          if d['departure_time'] >= transient_time]
    
    avg_wait_time = np.mean(steady_state_waits) if steady_state_waits else 0
    # ç­‰å¾…æ¦‚ç‡ P(W > 0)
    prob_wait = np.mean(np.array(steady_state_waits) > 1e-6) if steady_state_waits else 0
    
    print("\n--- IPP/M/c ä»¿çœŸ QoS ç»“æœ ---")
    print(f"å¹³å‡ç­‰å¾…æ—¶é—´ Wq: {avg_wait_time:.4f} åˆ†é’Ÿ (çº¦ {avg_wait_time/60:.2f} å°æ—¶)")
    print(f"ç­‰å¾…æ¦‚ç‡ P(W > 0): {prob_wait:.4f}")
    print(f"æ€»åˆ°è¾¾äº‹ä»¶æ•°: {len(data_storage['departures'])}")

# è°ƒç”¨ä¸»ä»¿çœŸå‡½æ•°
run_ipp_m_c_simulation()
import simpy
import random
import numpy as np
import pandas as pd
from typing import List, Tuple, Dict

# ----------------------------------------------------
# æœ€ç»ˆç¡®å®šçš„ IPP å’ŒæœåŠ¡å‚æ•°
# ----------------------------------------------------
LAMBDA_ON = 0.007525
PHI1 = 0.000375
PHI2 = 0.000375
MU_HAT = 0.000250
SIM_TIME = 5000000.0 # ä¿æŒå¤§ä»¿çœŸæ—¶é—´ä»¥ç¡®ä¿ç¨³æ€

# ----------------------------------------------------
# IPP/M/c ä»¿çœŸæ ¸å¿ƒå‡½æ•° (é‡æ–°å°è£…)
# ----------------------------------------------------
def ipp_arrival_process(env, servers, service_rate, data_storage):
    """æ ¹æ® IPP å‚æ•°ç”Ÿæˆåˆ°è¾¾äº‹ä»¶ã€‚"""
    pi_on = PHI2 / (PHI1 + PHI2)
    current_state = 1 if random.random() < pi_on else 0
    patient_id = 0

    while True:
        lambda_t = LAMBDA_ON if current_state == 1 else 0.0
        phi_out = PHI1 if current_state == 1 else PHI2
        
        if lambda_t > 1e-9:
            time_to_arrival = random.expovariate(lambda_t)
        else:
            time_to_arrival = float('inf') 
            
        time_to_switch = random.expovariate(phi_out)

        if time_to_arrival <= time_to_switch:
            yield env.timeout(time_to_arrival)
            patient_id += 1
            env.process(patient_flow(env, f'P_{patient_id}', servers, service_rate, data_storage))
        else:
            yield env.timeout(time_to_switch)
            current_state = 1 - current_state
def patient_flow(env, name, servers, service_rate, data_storage):
    """æ‚£è€…æµç¨‹ï¼šåˆ°è¾¾ã€ç­‰å¾…ã€æœåŠ¡ã€ç¦»å¼€ã€‚"""
    time_arrival = env.now
    with servers.request() as req:
        yield req
        time_start_service = env.now
        wait_time = time_start_service - time_arrival
        data_storage['wait_times'].append(wait_time)
        service_time = random.expovariate(service_rate)
        yield env.timeout(service_time)
        data_storage['departures'].append({'departure_time': env.now, 'wait_time': wait_time})

def run_single_ipp_simulation(num_servers: int, sim_time: float) -> Dict[str, float]:
    """è¿è¡Œä¸€æ¬¡ IPP/M/c ä»¿çœŸå¹¶è¿”å› QoS æŒ‡æ ‡ã€‚"""
    
    # æ£€æŸ¥æµé‡å¼ºåº¦ (Rho)
    lambda_avg = (LAMBDA_ON * PHI2) / (PHI1 + PHI2)
    rho = lambda_avg / (num_servers * MU_HAT)
    
    # å¦‚æœç³»ç»Ÿä¸ç¨³å®šï¼Œç›´æ¥è¿”å›æé«˜å€¼
    if rho >= 1:
        print(f"c={num_servers}: è­¦å‘Š! Rho={rho:.4f} >= 1. ç³»ç»Ÿä¸ç¨³å®šï¼Œè¿”å›å¤§å€¼ã€‚")
        return {
            "c": num_servers,
            "rho": rho,
            "Wq": 100000.0,  # è®¾å®šä¸€ä¸ªæå¤§å€¼è¡¨ç¤ºä¸ç¨³å®š
            "Pw": 1.0
        }
    env = simpy.Environment()
    servers = simpy.Resource(env, capacity=num_servers)
    data_storage = {'arrivals': [], 'departures': [], 'wait_times': [], 'switches': []}
    
    # è®¾ç½®éšæœºç§å­ä»¥ä¿è¯å®éªŒå¯å¤ç°æ€§ï¼ˆå¯é€‰ï¼Œä½†æ¨èï¼‰
    random.seed(num_servers * 100)
    
    env.process(ipp_arrival_process(env, servers, MU_HAT, data_storage))
    env.run(until=sim_time)
    
    # ç»“æœåˆ†æ (è·³è¿‡åˆå§‹ç¬æ€ 10%)
    transient_time = sim_time * 0.1
    steady_state_waits = [d['wait_time'] for d in data_storage['departures'] 
                          if d['departure_time'] >= transient_time]
    
    avg_wait_time = np.mean(steady_state_waits) if steady_state_waits else 0.0
    prob_wait = np.mean(np.array(steady_state_waits) > 1e-6) if steady_state_waits else 0.0
    
    return {
        "c": num_servers,
        "rho": rho,
        "Wq": avg_wait_time,
        "Pw": prob_wait
    }
# ----------------------------------------------------
# å•å…ƒæ ¼ 2: è¿è¡Œæ•æ„Ÿæ€§åˆ†æå’Œç»“æœå±•ç¤º (ä¿®æ­£ç‰ˆ)
# ----------------------------------------------------

# æ•æ„Ÿæ€§åˆ†æè®¾ç½®
C_RANGE = range(25, 41) # ä» 25 å¼ åºŠä½åˆ° 40 å¼ åºŠä½

print(f"--- åºŠä½æ•°æ•æ„Ÿæ€§åˆ†æå¼€å§‹ (c èŒƒå›´: {C_RANGE.start} åˆ° {C_RANGE.stop - 1}) ---")

results_list = []

for c in C_RANGE:
    # è¿è¡Œä¸€æ¬¡ IPP/M/c ä»¿çœŸ
    result = run_single_ipp_simulation(c, SIM_TIME)
    
    # ***ä¿®æ­£åçš„ä»£ç ï¼šå°†è½¬æ¢åçš„æŒ‡æ ‡æ·»åŠ åˆ° result å­—å…¸ä¸­***
    result['Wq_hrs'] = result['Wq'] / 60.0        # æ–°å¢åˆ—ï¼šå¹³å‡ç­‰å¾…æ—¶é—´ (å°æ—¶)
    result['Pw_pct'] = result['Pw'] * 100.0      # æ–°å¢åˆ—ï¼šç­‰å¾…æ¦‚ç‡ (%)
    
    results_list.append(result)
    print(f"c={c}: Rho={result['rho']:.4f}, Wq={result['Wq']:.2f} min (Wq_hrs={result['Wq_hrs']:.2f} hrs)")

# è½¬æ¢ä¸º DataFrame å¹¶æ ¼å¼åŒ–è¾“å‡º
df_sensitivity = pd.DataFrame(results_list)

# é€‰æ‹©å¹¶é‡å‘½åæœ€ç»ˆè¾“å‡ºåˆ— (ç°åœ¨ Wq_hrs å’Œ Pw_pct å­˜åœ¨äº DataFrame ä¸­)
df_sensitivity = df_sensitivity[['c', 'rho', 'Wq', 'Wq_hrs', 'Pw_pct']]
df_sensitivity.columns = ['åºŠä½æ•° c', 'æµé‡å¼ºåº¦ Rho', 'å¹³å‡ç­‰å¾…æ—¶é—´ Wq (åˆ†é’Ÿ)', 'å¹³å‡ç­‰å¾…æ—¶é—´ Wq (å°æ—¶)', 'ç­‰å¾…æ¦‚ç‡ Pw (%)']
print("\n--- æ•æ„Ÿæ€§åˆ†æç»“æœ ---")
# ä½¿ç”¨ to_string ä»¥ç¡®ä¿åœ¨ä»»ä½•ç¯å¢ƒä¸­éƒ½èƒ½æ¸…æ™°å±•ç¤ºå®Œæ•´è¡¨æ ¼
print(df_sensitivity.to_string(index=False, float_format="%.4f"))

# ----------------------------------------------------
# å¯è§†åŒ– (å¯é€‰)
# ----------------------------------------------------
try:
    import matplotlib.pyplot as plt
    
    # è®¾ç½®ä¸­æ–‡å­—ä½“ï¼ˆå¯é€‰ï¼Œå¦‚æœæ‚¨çš„ç¯å¢ƒæ”¯æŒï¼‰
    # plt.rcParams['font.sans-serif'] = ['SimHei'] 
    # plt.rcParams['axes.unicode_minus'] = False
    
    plt.figure(figsize=(12, 5))
    
    # å›¾ 1: å¹³å‡ç­‰å¾…æ—¶é—´éšåºŠä½æ•° c çš„å˜åŒ–
    plt.subplot(1, 2, 1)
    plt.plot(df_sensitivity['åºŠä½æ•° c'], df_sensitivity['å¹³å‡ç­‰å¾…æ—¶é—´ Wq (å°æ—¶)'], marker='o', linestyle='-', color='b')
    plt.axvline(x=30, color='r', linestyle='--', label='å½“å‰åºŠä½æ•° (c=30)')
    plt.title('åºŠä½æ•° (c) å¯¹å¹³å‡ç­‰å¾…æ—¶é—´çš„å½±å“')
    plt.xlabel('ICU åºŠä½æ•° (c)')
    plt.ylabel('å¹³å‡ç­‰å¾…æ—¶é—´ Wq (å°æ—¶)')
    plt.grid(True, linestyle=':', alpha=0.6)
    plt.legend()
    # å›¾ 2: ç­‰å¾…æ¦‚ç‡éšåºŠä½æ•° c çš„å˜åŒ–
    plt.subplot(1, 2, 2)
    plt.plot(df_sensitivity['åºŠä½æ•° c'], df_sensitivity['ç­‰å¾…æ¦‚ç‡ Pw (%)'], marker='s', linestyle='-', color='g')
    plt.axvline(x=30, color='r', linestyle='--', label='å½“å‰åºŠä½æ•° (c=30)')
    plt.title('åºŠä½æ•° (c) å¯¹ç­‰å¾…æ¦‚ç‡çš„å½±å“')
    plt.xlabel('ICU åºŠä½æ•° (c)')
    plt.ylabel('ç­‰å¾…æ¦‚ç‡ Pw (%)')
    plt.grid(True, linestyle=':', alpha=0.6)
    plt.legend()
    
    plt.tight_layout()
    plt.show()

except ImportError:
    print("\nâš ï¸ è­¦å‘Š: ç¼ºå°‘ matplotlib åº“ã€‚æ— æ³•ç”Ÿæˆå›¾è¡¨ã€‚")
